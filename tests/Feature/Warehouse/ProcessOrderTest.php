<?php

namespace Tests\Feature\Warehouse;

use App\Models\User;
use App\Warehouse\Domain\Orders\Order;
use App\Warehouse\Domain\Orders\OrderLine;
use App\Warehouse\Domain\Products\Product;
use App\Warehouse\Domain\Repositories\OrderRepositoryInterface;
use App\Warehouse\Domain\Services\InventoryServiceInterface;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionBackorderRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionOrderRepository;
use App\Warehouse\Infrastructure\Persistence\InMemory\Repositories\InMemoryCollectionPicklistRepository;
use Illuminate\Foundation\Testing\DatabaseMigrations;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Mockery\MockInterface;
use Tests\TestCase;

class ProcessOrderTest extends TestCase
{
    use DatabaseMigrations;
    use RefreshDatabase;

    protected int $tenantId;
    protected InMemoryCollectionOrderRepository $orderRepository;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->user = User::factory()->create();
        $this->tenantId = $this->user->tenant_id;
        $this->actingAs($this->user);

        $this->orderRepository = new InMemoryCollectionOrderRepository();
        $this->app->instance(OrderRepositoryInterface::class, $this->orderRepository);

    }

    /** @test */
    public function it_should_convert_all_order_lines_to_picklist_when_they_are_in_stock()
    {
        $this->withoutExceptionHandling();

        // Given
        $order = Order::factory()->make([
            'tenant_id' => $this->tenantId
        ]);

        $order->createPicklist($order->orderLines());

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('getStock')
                ->andReturn(99999);

            $mock->shouldReceive('adjustStock')
                ->andReturnTrue();
        });

        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        $url = route('process-order', [
            "orderReference" => $order->reference(),
        ]);

        // When
        $response = $this->get($url, [
            "Accept" => "application/json"
        ]);

        // Then
        $order = $this->orderRepository->findOneByReferenceAndTenantId($order->reference(), $order->tenantId());

        self::assertEquals(1, $order->picklists()->count());
        self::assertEquals($order->orderLines(), $order->picklists()->first()->orderLines());
    }

    /** @test */
    public function it_should_create_one_backorder_when_both_order_lines_are_out_of_stock()
    {
        $this->withoutExceptionHandling();

        // Given
        $order = Order::factory()->make([
            'tenant_id' => $this->tenantId
        ]);

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('getStock')
                ->andReturn(0);
        });

        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        $url = route('process-order', [
            "orderReference" => $order->reference()
        ]);

        // When
        $response = $this->get($url);

        // Then
        $foundOrder = $this->orderRepository->findOneByReferenceAndTenantId($order->reference(), $order->tenantId());

        self::assertEmpty($foundOrder->picklists());
        self::assertEquals(1, $foundOrder->backorders()->count());
        self::assertEquals($foundOrder->backorders()->first()->orderLines(), $order->orderLines());
    }

    /** @test */
    public function it_should_create_backorder_from_out_of_stock_order_lines_and_picklist_from_in_stock_order_lines()
    {
        $this->withoutExceptionHandling();

        // Given
        $orderReference = "Test Order Reference";

        $product1 = new Product("Test Product Code 1");
        $product2 = new Product("Test Product Code 2");
        $orderLine1 = new OrderLine($product1, 1);
        $orderLine2 = new OrderLine($product2, 1);
        $orderLines = collect(array($orderLine1, $orderLine2));
        $customerNumber = "Test Customer Number";
        $isGuestOrder = false;
        $order = Order::factory()->make([
            "reference" => $orderReference,
            "order_lines" => $orderLines,
            "customer_number" => $customerNumber,
            "is_guest_order" => $isGuestOrder,
            'tenant_id' => $this->tenantId
        ]);

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) use ($product1, $product2) {
            $mock->shouldReceive('getStock')
                ->andReturnUsing(function (string $productCode) use ($product1, $product2) {
                        if ($productCode === $product1->productCode())
                        {
                            return 10;
                        }

                        return 0;
                });

            $mock->shouldReceive('adjustStock')
                ->andReturnTrue();
        });


        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        $url = route('process-order', [
            "orderReference" => $orderReference
        ]);

        // When
        $response = $this->get($url);

        // Then
        $foundOrder = $this->orderRepository->findOneByReferenceAndTenantId($orderReference, $this->tenantId);

        self::assertEquals($orderLine2, $foundOrder->backorders()->first()->orderLines()->first());
        self::assertEquals($orderLine1, $foundOrder->picklists()->first()->orderLines()->first());
    }

    /** @test */
    public function it_should_not_process_order_from_other_tenant()
    {
        $this->withoutExceptionHandling();

        // Given
        $order = Order::factory()->make([
            "tenant_id" => $this->tenantId + 1
        ]);

        $url = route('process-order', [
            "orderReference" => $order->reference(),
        ]);

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) {
            $mock->shouldReceive('getStock')
                ->andReturn(0);
        });

        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        // When
        $response = $this->get($url);

        // Then
        $foundOrder = $this->orderRepository->findOneByReferenceAndTenantId($order->reference(), $this->tenantId + 1);

        self::assertEmpty($foundOrder->picklists());
        self::assertEmpty($foundOrder->backorders());
    }

    /** @test */
    public function it_return_error_when_order_not_found()
    {
        // Given
        $order = Order::factory()->make();
        $url = route('process-order', [
            "orderReference" => $order->reference(),
        ]);

        // When
        $response = $this->get($url);

        // Then
        $response->assertJson([
            'error' => [
                'code' => 1,
                'message' => 'Order with reference ' . $order->reference() . ' not found'
            ]
        ]);
    }

    /** @test */
    public function it_should_return_error_when_product_not_found()
    {
        // Given
        $order = Order::factory()->make([
            'tenant_id' => $this->tenantId
        ]);
        $orderRepository = new InMemoryCollectionOrderRepository();
        $this->app->bind(OrderRepositoryInterface::class, function () use ($orderRepository) {return $orderRepository;});
        $orderRepository->save($order);

        $url = route('process-order', [
            "orderReference" => $order->reference(),
        ]);

        // When
        $response = $this->get($url);

        // Then
        $response->assertJson([
            'error' => [
                'code' => 1,
                'message' => 'Product with product code ' . $order->orderLines()->first()->product()->productCode() . ' not found'
            ]
        ]);
    }

    /** @test */
    public function it_should_create_backorder_and_picklist_only_once()
    {
        $this->withoutExceptionHandling();

        // Given
        $orderReference = "Test Order Reference";

        $product1 = new Product("Test Product Code 1");
        $product2 = new Product("Test Product Code 2");
        $orderLine1 = new OrderLine($product1, 1);
        $orderLine2 = new OrderLine($product2, 1);
        $orderLines = collect(array($orderLine1, $orderLine2));
        $customerNumber = "Test Customer Number";
        $isGuestOrder = false;
        $order = Order::factory()->make([
            "reference" => $orderReference,
            "order_lines" => $orderLines,
            "customer_number" => $customerNumber,
            "is_guest_order" => $isGuestOrder,
            'tenant_id' => $this->tenantId
        ]);

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) use ($product1, $product2) {
            $mock->shouldReceive('getStock')
                ->andReturnUsing(function (string $productCode) use ($product1, $product2) {
                    if ($productCode === $product1->productCode())
                    {
                        return 10;
                    }

                    return 0;
                });

            $mock->shouldReceive('adjustStock')
                ->andReturnTrue();
        });

        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        $url = route('process-order', [
            "orderReference" => $orderReference
        ]);

        // When
        $response = $this->get($url);
        $response = $this->get($url);

        // Then
        $foundOrder = $this->orderRepository->findOneByReferenceAndTenantId($orderReference, $this->tenantId);

        self::assertEquals(1, $foundOrder->backorders()->count());
        self::assertEquals(1, $foundOrder->picklists()->count());
    }

    /** @test */
    public function it_should_deduct_stock_of_order_lines_of_picklist()
    {
        $this->withoutExceptionHandling();

        // Given
        $order = Order::factory()->make([
            'tenant_id' => $this->tenantId
        ]);

        $order->createPicklist($order->orderLines());

        $this->orderRepository->save($order);

        $inventoryServiceMock = $this->mock(InventoryServiceInterface::class, function (MockInterface $mock) use ($order) {
            $mock->shouldReceive('getStock')
                ->andReturn(99999);

            $mock->shouldReceive('adjustStock')
                    ->times($order->orderLines()->count())
                    ->andReturnTrue();
        });

        $this->app->instance(InventoryServiceInterface::class, $inventoryServiceMock);

        $url = route('process-order', [
            "orderReference" => $order->reference(),
        ]);

        // When
        $response = $this->get($url, [
            "Accept" => "application/json"
        ]);

        // Then
        $order = $this->orderRepository->findOneByReferenceAndTenantId($order->reference(), $order->tenantId());

        self::assertEquals(1, $order->picklists()->count());
        self::assertEquals($order->orderLines(), $order->picklists()->first()->orderLines());
    }
}
